[
  {
    "objectID": "node_types.html",
    "href": "node_types.html",
    "title": "Node types",
    "section": "",
    "text": "Node types\nThe execution of most of the nodes consists of a single schedule compilation, a single measurement and a single post-processing. Although for most of the nodes this workflow suffices, there are exceptions while this workflow can become limiting in more advanced implementations.\nTo allow greater flexibilty in the node implementations the nodes are categorized:\n\nAccording to whether they compile once or multiple times:\n\nnode.type = simple_sweep: if it compiles once\nnode.type = parameterized_sweep: if it compiles multiple times\n\nAccording to whether the sweeping parameters are swept whithin the schedule or not:\n\nThere is only node.schedule_samplespace if the sweeping takes place whithin the schedule\nThere are both node.schedule_samplespace and node.external_samplespace if there are sweeping parameters outside of the scedule. For example the coupler_spectroscopy node sweeps the dc_current outside of the schedule:\n\n\n  class Coupler_Spectroscopy_Node(BaseNode):\n    measurement_obj = Two_Tones_Multidim\n    analysis_obj = CouplerSpectroscopyAnalysis\n\n    def __init__(self, name: str, all_qubits: list[str], couplers, **schedule_keywords):\n        super().__init__(name, all_qubits, **schedule_keywords)\n        self.couplers = couplers\n        self.redis_field = ['parking_current']\n        self.all_qubits = self.coupled_qubits\n\n        self.schedule_samplespace = {\n            'spec_frequencies': {\n                qubit: qubit_samples(qubit) for qubit in self.all_qubits\n            }\n        }\n\n        self.external_samplespace = {\n            'dc_currents': {\n                self.coupler: np.arange(-2.5e-3, 2.5e-3, 500e-6)\n            },\n        }\n\n    def pre_measurement_operation(self, reduced_ext_space):\n        iteration_dict = reduced_ext_space['dc_currents']\n\n        this_iteration_value = list(iteration_dict.values())[0]\n        print(f'{ this_iteration_value = }')\n        self.spi_dac.set_dac_current(self.dac, this_iteration_value)\nBy default every node every node is assigned a node.type attribute at the BaseNode class:\nself.type = simple_sweep\nThis attribute can be overwritten at the implementation of the class of each node. An example of a parameterized_sweep node type is Randomized_Benchmarking as each new iteration requires a the schedule to be recompiled with a different random seed.\nThe tergite_acl/scripts/node_supervisor.py is responcible to distinguish between each node variation.\n\nExamples of nodes requiring an externbal samplespace:\n\ncoupler_spectroscopy sweeps the dc_current which is set by the SPI rack not the cluster\nT1 sweeps a repetetion index to repeat the measurement many times\nrandomized_benchmarking sweeps different seeds. Although the seed is a schedule parameter, sweeping outside the schedule improves memory utilization."
  },
  {
    "objectID": "available_nodes.html",
    "href": "available_nodes.html",
    "title": "Available Nodes",
    "section": "",
    "text": "punchout\nresonator_spectroscopy\nresonator_spectroscopy_1\nresonator_spectroscopy_2\nro_frequency_two_state_optimization\nro_frequency_three_state_optimization\nro_amplitude_two_state_optimization\nro_amplitude_three_state_optimization\n\n\n\n\n\nqubit_01_spectroscopy\nqubit_01_spectroscopy_pulsed\nrabi_oscillations\nramsey_correction\nqubit_12_spectroscopy_pulsed\nqubit_12_spectroscopy_multidim\nrabi_oscillations_12\nramsey_correction_12\nadaptive_motzoi_parameter\nn_rabi_oscillations\nstate_discrimination\n\n\n\n\n\ncoupler_spectroscopy\ncoupler_resonator_spectroscopy\n\n\n\n\n\nT1\nT2\nT2_echo\nrandomized_benchmarking\nall_XY"
  },
  {
    "objectID": "available_nodes.html#readout-nodes",
    "href": "available_nodes.html#readout-nodes",
    "title": "Available Nodes",
    "section": "",
    "text": "punchout\nresonator_spectroscopy\nresonator_spectroscopy_1\nresonator_spectroscopy_2\nro_frequency_two_state_optimization\nro_frequency_three_state_optimization\nro_amplitude_two_state_optimization\nro_amplitude_three_state_optimization"
  },
  {
    "objectID": "available_nodes.html#qubit-control-nodes",
    "href": "available_nodes.html#qubit-control-nodes",
    "title": "Available Nodes",
    "section": "",
    "text": "qubit_01_spectroscopy\nqubit_01_spectroscopy_pulsed\nrabi_oscillations\nramsey_correction\nqubit_12_spectroscopy_pulsed\nqubit_12_spectroscopy_multidim\nrabi_oscillations_12\nramsey_correction_12\nadaptive_motzoi_parameter\nn_rabi_oscillations\nstate_discrimination"
  },
  {
    "objectID": "available_nodes.html#coupler-nodes",
    "href": "available_nodes.html#coupler-nodes",
    "title": "Available Nodes",
    "section": "",
    "text": "coupler_spectroscopy\ncoupler_resonator_spectroscopy"
  },
  {
    "objectID": "available_nodes.html#characterization-nodes",
    "href": "available_nodes.html#characterization-nodes",
    "title": "Available Nodes",
    "section": "",
    "text": "T1\nT2\nT2_echo\nrandomized_benchmarking\nall_XY"
  },
  {
    "objectID": "operation.html",
    "href": "operation.html",
    "title": "Tergite Automatic Calibration",
    "section": "",
    "text": "The package ships with a command line interface to solve some common tasks that appear quite often.\nIn the following there are a number of useful commands, but if you want to find out all commands use: acli --help\nTo delete all redis entries: acli node reset -a\nTo reset a particular node: acli node reset -n &lt;nodename&gt;\nFor example to reset the node rabi_oscillations run the command:\nacli node reset -n rabi_oscillations\nTo start a new calibration sequence according to the configuration files:\npython tergite_acl/scripts/calibration_supervisor.py\nor\nacli calibration start"
  },
  {
    "objectID": "operation.html#operation",
    "href": "operation.html#operation",
    "title": "Tergite Automatic Calibration",
    "section": "",
    "text": "The package ships with a command line interface to solve some common tasks that appear quite often.\nIn the following there are a number of useful commands, but if you want to find out all commands use: acli --help\nTo delete all redis entries: acli node reset -a\nTo reset a particular node: acli node reset -n &lt;nodename&gt;\nFor example to reset the node rabi_oscillations run the command:\nacli node reset -n rabi_oscillations\nTo start a new calibration sequence according to the configuration files:\npython tergite_acl/scripts/calibration_supervisor.py\nor\nacli calibration start"
  },
  {
    "objectID": "operation.html#structure",
    "href": "operation.html#structure",
    "title": "Tergite Automatic Calibration",
    "section": "Structure",
    "text": "Structure\nFor each calibration node: compilation -&gt; execution -&gt; post-processing -&gt; redis updating"
  },
  {
    "objectID": "operation.html#data-browsing",
    "href": "operation.html#data-browsing",
    "title": "Tergite Automatic Calibration",
    "section": "Data browsing",
    "text": "Data browsing\nDatasets are stored in data_directory Can be browsed with the dataset browser (coming soon)"
  },
  {
    "objectID": "operation.html#development",
    "href": "operation.html#development",
    "title": "Tergite Automatic Calibration",
    "section": "Development",
    "text": "Development\nWhen submitting contributions, please prepend your commit messages with: fix: for bug fixes feat: for introducing a new feature (e.g. a new measurement node or a new analysis class) chore: for refractoring changes or any change that doesn’t affect the functionality of the code docs: for changes in the README, docstrings etc test: or dev: for testing or development changes (e.g. profiling scripts)"
  },
  {
    "objectID": "getting_started.html",
    "href": "getting_started.html",
    "title": "Getting started",
    "section": "",
    "text": "This project contains an orchistration manager, a collection of callibration schedules and a collection of post-processing & analysis routines. It is tailored for the tune-up of the 25 qubits QPU at Chalmers, QTL. This repository utilizes redis for on memory data storage. As redis operates only on Linux systems, this repo can only work\n\neither on Linux distributions\nor WSL (Windows Subsystem for Linux) environments, installed on a Windows system.\n\nTo install WSL, it is required Windows 10 of version at least 1903.\n\n\n\n\n\ngit clone git@github.com:chalmersnextlabs-quantum/tergite-autocalibration.git\n\n\n\nhttps://redis.io/docs/getting-started/installation/install-redis-on-linux/\n\n\n\nredis-server\n\n\n\nIf for example you want to name your environment tac, you create it as\nconda create --name tac python=3.9\n\n\n\nconda activate tac\n\n\n\nsource activate tac\n\n\n\ncd tergite-autocalibration-lite/\nFrom now on, it is assumed that all commands are executed from the project root directory.\n\n\n\npip install -e .\nHere . is the root directory (i.e. the directory that contains the pyproject.toml file)\n\n\n\n\nBefore the first run of the callibration suite a number of configuration files need to be set up. These files describe our initial knowledge on the system as well as the connectivity with the measurement hardware.\n\n\nAll the settings and paths are contained in the .env file. Since this file contains user specific settings, it is git-ignored, it must be created by the user. For convinience a template file dot-env-template.txt already exists.\nFirst copy the template file to the .env (this creates the .env file if it doesn’t exist):\ncp dot-env-template .env\nThen edit the newly created .env file according to your system. For example here’s how the user lab-user may complete the .env file:\n# Copy this file to a .env file in the tergite-autocalibration folder on the root level.\n# The .env file is a simple list of keys and values. It is also known as the INI file on MS Windows.\n# Fill in the necessary values.\n\n# DEFAULT_PREFIX is added to logfiles, redis entries and in the data directory\n# Default: cal\nDEFAULT_PREFIX=calibration\n\n# Directory settings\n# ROOT_DIR defines the top-level folder of the tergite-autocalibration-lite folder\n# Default: two levels up from the config\nROOT_DIR='/home/lab-user/github/tergite-acl/'\n\n# DATA_DIR defines where plots are stored\nDATA_DIR='/home/lab-user/github/tergite-acl/data_directory/'\n\n# CONFIG_DIR defines where the configuration is stored\nCONFIG_DIR='/home/lab-user/github/tergite-acl/config_dir/'\n\n\n# Configuration settings\n# It is assumed that all these paths are relative to CONFIG_DIR\n# HARDWARE_CONFIG is what Q-BLOX needs to compile schedules on the hardware\n# It should be a file in json format, there is no default file\nHARDWARE_CONFIG='HARDWARE_CONFIGURATION.json'\n\n# DEVICE_CONFIG contains the initial values for the device configuration\nDEVICE_CONFIG='device_config.toml'\n\n# Configuration variables\n# CLUSTER_IP is the IP address of the instrument cluster to connect with\nCLUSTER_IP='162.0.2.162'\n# SPI_SERIAL_PORT is the port on which the spi rack is connected\nSPI_SERIAL_PORT='/dev/ttyACM0'\n\n# APP_SETTINGS reflect which environment the calibration is to run in.\n# Options\n#  - development\n#  - production\n#  - staging\n#  - test\n# Default: production\n# TODO: currently we are only using the calibration in the development mode\nRUN_MODE=development\n\n# REDIS_PORT is the port which to use when connecting to redis\nREDIS_PORT=6379\n# REDIS_CONNECTION will be automatically created in settings.py\n\n# PLOTTING is a boolean to indicate whether plots should be shown or whether plots should be silent in the background\n# Default: True\nPLOTTING=True"
  },
  {
    "objectID": "getting_started.html#installation",
    "href": "getting_started.html#installation",
    "title": "Getting started",
    "section": "",
    "text": "This project contains an orchistration manager, a collection of callibration schedules and a collection of post-processing & analysis routines. It is tailored for the tune-up of the 25 qubits QPU at Chalmers, QTL. This repository utilizes redis for on memory data storage. As redis operates only on Linux systems, this repo can only work\n\neither on Linux distributions\nor WSL (Windows Subsystem for Linux) environments, installed on a Windows system.\n\nTo install WSL, it is required Windows 10 of version at least 1903."
  },
  {
    "objectID": "getting_started.html#repository-installation",
    "href": "getting_started.html#repository-installation",
    "title": "Getting started",
    "section": "",
    "text": "git clone git@github.com:chalmersnextlabs-quantum/tergite-autocalibration.git\n\n\n\nhttps://redis.io/docs/getting-started/installation/install-redis-on-linux/\n\n\n\nredis-server\n\n\n\nIf for example you want to name your environment tac, you create it as\nconda create --name tac python=3.9\n\n\n\nconda activate tac\n\n\n\nsource activate tac\n\n\n\ncd tergite-autocalibration-lite/\nFrom now on, it is assumed that all commands are executed from the project root directory.\n\n\n\npip install -e .\nHere . is the root directory (i.e. the directory that contains the pyproject.toml file)"
  },
  {
    "objectID": "getting_started.html#setting-up-system-configuration-files",
    "href": "getting_started.html#setting-up-system-configuration-files",
    "title": "Getting started",
    "section": "",
    "text": "Before the first run of the callibration suite a number of configuration files need to be set up. These files describe our initial knowledge on the system as well as the connectivity with the measurement hardware.\n\n\nAll the settings and paths are contained in the .env file. Since this file contains user specific settings, it is git-ignored, it must be created by the user. For convinience a template file dot-env-template.txt already exists.\nFirst copy the template file to the .env (this creates the .env file if it doesn’t exist):\ncp dot-env-template .env\nThen edit the newly created .env file according to your system. For example here’s how the user lab-user may complete the .env file:\n# Copy this file to a .env file in the tergite-autocalibration folder on the root level.\n# The .env file is a simple list of keys and values. It is also known as the INI file on MS Windows.\n# Fill in the necessary values.\n\n# DEFAULT_PREFIX is added to logfiles, redis entries and in the data directory\n# Default: cal\nDEFAULT_PREFIX=calibration\n\n# Directory settings\n# ROOT_DIR defines the top-level folder of the tergite-autocalibration-lite folder\n# Default: two levels up from the config\nROOT_DIR='/home/lab-user/github/tergite-acl/'\n\n# DATA_DIR defines where plots are stored\nDATA_DIR='/home/lab-user/github/tergite-acl/data_directory/'\n\n# CONFIG_DIR defines where the configuration is stored\nCONFIG_DIR='/home/lab-user/github/tergite-acl/config_dir/'\n\n\n# Configuration settings\n# It is assumed that all these paths are relative to CONFIG_DIR\n# HARDWARE_CONFIG is what Q-BLOX needs to compile schedules on the hardware\n# It should be a file in json format, there is no default file\nHARDWARE_CONFIG='HARDWARE_CONFIGURATION.json'\n\n# DEVICE_CONFIG contains the initial values for the device configuration\nDEVICE_CONFIG='device_config.toml'\n\n# Configuration variables\n# CLUSTER_IP is the IP address of the instrument cluster to connect with\nCLUSTER_IP='162.0.2.162'\n# SPI_SERIAL_PORT is the port on which the spi rack is connected\nSPI_SERIAL_PORT='/dev/ttyACM0'\n\n# APP_SETTINGS reflect which environment the calibration is to run in.\n# Options\n#  - development\n#  - production\n#  - staging\n#  - test\n# Default: production\n# TODO: currently we are only using the calibration in the development mode\nRUN_MODE=development\n\n# REDIS_PORT is the port which to use when connecting to redis\nREDIS_PORT=6379\n# REDIS_CONNECTION will be automatically created in settings.py\n\n# PLOTTING is a boolean to indicate whether plots should be shown or whether plots should be silent in the background\n# Default: True\nPLOTTING=True"
  },
  {
    "objectID": "configuration_files.html",
    "href": "configuration_files.html",
    "title": "Configuration Files",
    "section": "",
    "text": "Here the connection is made between the Qblox cluster physical ports and clocks to the qubits and couplers of the QPU.\nThe file must be placed at the directory tergite-acl/config_dir/\nGiven a .csv file after a mixer calibration the function ... can create instantly the corresponding JSON file.\n\n\n\nHere we set reasonable initial parameters\n\n\n\nHere we input the initial values for the resonator and qubits frequencies, assumed that they have been acquired through VNA measurements, design targets or previous manual measurements. /tergite_acl/config/VNA_values.py"
  },
  {
    "objectID": "configuration_files.html#hardware-configuration-file-json",
    "href": "configuration_files.html#hardware-configuration-file-json",
    "title": "Configuration Files",
    "section": "",
    "text": "Here the connection is made between the Qblox cluster physical ports and clocks to the qubits and couplers of the QPU.\nThe file must be placed at the directory tergite-acl/config_dir/\nGiven a .csv file after a mixer calibration the function ... can create instantly the corresponding JSON file."
  },
  {
    "objectID": "configuration_files.html#device-configuration-file-toml",
    "href": "configuration_files.html#device-configuration-file-toml",
    "title": "Configuration Files",
    "section": "",
    "text": "Here we set reasonable initial parameters"
  },
  {
    "objectID": "configuration_files.html#vna-resonator-qubit-frequencies",
    "href": "configuration_files.html#vna-resonator-qubit-frequencies",
    "title": "Configuration Files",
    "section": "",
    "text": "Here we input the initial values for the resonator and qubits frequencies, assumed that they have been acquired through VNA measurements, design targets or previous manual measurements. /tergite_acl/config/VNA_values.py"
  },
  {
    "objectID": "new_node_creation.html",
    "href": "new_node_creation.html",
    "title": "To create a new node:",
    "section": "",
    "text": "In the file tergite_acl/lib/node_factory.py expand the dictionary self.node_implementations with a new entry: The key should be a string of the node name and the value should be the object that contains the implementation details. This object should be imported from either tergite_acl/lib/nodes/qubit_control_nodes.py, tergite_acl/lib/nodes/coupler_nodes.py, tergite_acl/lib/nodes/readout_nodes.py or tergite_acl/lib/nodes/characterization_nodes.py\nIn the file tergite_acl/lib/nodes/graph.py in the list graph_dependencies insert the edges that describe the position of the new node in the Directed Acyclic Graph. There are two entries required (or one entry if the new node is the last on its path):\n\n\n('previous_node','new_node')\n('new_node', 'next_node')\n\n\nIn the tergite_acl/config/device_config.toml set the quantity of interest at nan value\n\n\n\nEach node implementation object should contain a reference to the measurement object, the analysis object, the list of redis fields that the analysis updates and the samplespace of the measurement. For example on the Rabi Rabi Oscillations Node:\nclass Rabi_Oscillations_Node(BaseNode):\n    measurement_obj = Rabi_Oscillations\n    analysis_obj = RabiAnalysis\n\n    def __init__(self, name: str, all_qubits: list[str], **node_dictionary):\n        super().__init__(name, all_qubits, **node_dictionary)\n        self.redis_field = ['rxy:amp180']\n        self.schedule_samplespace = {\n            'mw_amplitudes': {\n                qubit: np.linspace(0.002, 0.80, 101) for qubit in self.all_qubits\n            }\n        }\n\n\nThe measurement_obj is imported from tergite_acl/lib/calibration_schedules/ and contains the class that generates the appropriate measurement schedule. To initialize we require a dicttionary of the extended transmons:\ntransmons: dict[str, ExtendedTransmon]\nIt must contain a method called schedule_function that expects the node.samplespace as input and returns the complete schedule.\n\n\n\nThe analysis_obj is imported from tergite_acl/lib/analysis/ and contains the class that perform the analysis for a single qubit. It must contain a run_fitting method and a plotter method\n\n\n\nNodes are divided in two distict categories:\n\nsimple_sweep: where the Quantify Schedule is compiled only once\nparameterized_sweep: where the node requires multiple iterations and each iteration requires a new recompilation.\n\nFurthermore each node can expect two types of samplespaces:\n\nschedule_samplespace: parameter values to be input to the schedule function\nexterbal_samplespace: parameter values for quantities that are not set during a schedule\n\nDetails on the implementation on the Node types section."
  },
  {
    "objectID": "new_node_creation.html#node-implementation-object",
    "href": "new_node_creation.html#node-implementation-object",
    "title": "To create a new node:",
    "section": "",
    "text": "Each node implementation object should contain a reference to the measurement object, the analysis object, the list of redis fields that the analysis updates and the samplespace of the measurement. For example on the Rabi Rabi Oscillations Node:\nclass Rabi_Oscillations_Node(BaseNode):\n    measurement_obj = Rabi_Oscillations\n    analysis_obj = RabiAnalysis\n\n    def __init__(self, name: str, all_qubits: list[str], **node_dictionary):\n        super().__init__(name, all_qubits, **node_dictionary)\n        self.redis_field = ['rxy:amp180']\n        self.schedule_samplespace = {\n            'mw_amplitudes': {\n                qubit: np.linspace(0.002, 0.80, 101) for qubit in self.all_qubits\n            }\n        }\n\n\nThe measurement_obj is imported from tergite_acl/lib/calibration_schedules/ and contains the class that generates the appropriate measurement schedule. To initialize we require a dicttionary of the extended transmons:\ntransmons: dict[str, ExtendedTransmon]\nIt must contain a method called schedule_function that expects the node.samplespace as input and returns the complete schedule.\n\n\n\nThe analysis_obj is imported from tergite_acl/lib/analysis/ and contains the class that perform the analysis for a single qubit. It must contain a run_fitting method and a plotter method\n\n\n\nNodes are divided in two distict categories:\n\nsimple_sweep: where the Quantify Schedule is compiled only once\nparameterized_sweep: where the node requires multiple iterations and each iteration requires a new recompilation.\n\nFurthermore each node can expect two types of samplespaces:\n\nschedule_samplespace: parameter values to be input to the schedule function\nexterbal_samplespace: parameter values for quantities that are not set during a schedule\n\nDetails on the implementation on the Node types section."
  }
]
